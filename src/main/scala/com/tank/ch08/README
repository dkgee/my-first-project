

8.2 本地函数
    1，程序应该被结构成若干个小的函数，每块实现定义完备的任务。
        优点：使用小模块可以组装成更复杂的事物。
        原则：每小模块应该简化到能够充分足够单独理解
8.3 头等函数
    1，Scala的函数，不仅可以定义和调用函数，还可以把它们写成匿名的字面量(literal),并把它们作为值传递。
    2，函数的字面量被编译进类，并在运行期间实例化为函数值。函数的字面量和值得区别在于函数字面量存在于源代码，而
        函数值作为对象存在于运行期。就像类(源代码)和对象(运行期)之间的关系。
8.4 函数字面量的短路式
    1，目标类型化(target typing)
8.5 占位符语法
    1，只要每个参数在函数字面量内仅出现一次，可以把下划线当做一个或更多参数的占位符。
    2，可以把下划线看做表达式需要被“填入”和“空白”。这个空白在每次函数被调用的时候用函数的参数填入。
    3，编译器无法识别时，使用冒号指定下划线类型
        val f = (_: Int) + (_: Int)
    4，多个下划线指代多个参数，而不是单个参数的重复使用。
8.6 部分应用函数
    1，还可以使用单个下划线替换整个参数列表。
        println(_)或 println _
    2，函数名和下划线之间留一个空格。
    3，利用上述方式使用下划线，你就正在写一个部分应用函数(partially applied function)
    4，print _或 sum _ 可以去掉下划线从而表达得更简明。
        someNumbers.foreach(println _) 可以被替换为  someNumbers.foreach(println)
        上述方式仅在要写函数的地方。
    5，也只有在需要函数类型的地方，Scala才允许省略这个仅用的_
8.7 闭包
    1，依照more这个函数字面量在运行时创建的函数值(对象)被称为闭包：closure。名称源自于通过“捕获”自由变量的绑定，从而
        对函数字面量执行的“关闭”行动。
    2，在使用的实例是那个在闭包被创建的时候活跃的。
    3，每次在函数使用的时候都会创建一个新闭包。每个闭包都会访问闭包创建时活跃的more变量。
8.8 重复参数
    1，可以指明函数的最后一个参数是重复的，从而允许想函数传入可变长度的参数列表，只需在参数的类型之后放入一个星号。
        def echo(args: String*) = for(arg <- args) println(arg)
        或 echo(arr: _*)
8.9 尾递归
    1，尾调用优化限定了方法或嵌套函数必须是最后一个操作调用本身，而不是转到某个函数值或什么其他函数情况

